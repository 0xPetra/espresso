////////////////////////////////////////////////////////////////////////////////
// Hierarchical deterministic key generation
//
// This module provides an interface for procedurally generating a tree of keys.
// It does not implement the full BIP 32 standard for HD wallets, only the
// features relevant to our system. For example, BIP 32 provides features for
// deriving public keys from parent public keys without knowing any private keys,
// to allow for trustless key rotation. This (key rotation) is less important in
// our system, which provides unlinkability by default.
//
// The keys generated by this interface are 32-byte pseudo-random values with no
// internal structure. They have no relationship to elliptic curve points, but
// they can be used as a random seed for generating elliptic curve keys for use
// in the wallet. The lack of structure makes these keys useful for other
// applications too, though, such as encryption and decryption.
//
// The relationship between derived keys and their parents can be described as a
// tree. A single root KeyTree is generated from some external means (such as
// entropy, or from a password using a KDF). This root tree can be used to derive
// sub-trees using `derive_sub_tree`, and any KeyTree can be used to derive more
// sub-trees as well as leaf keys. Each derived KeyTree and Key is a commitment
// to its parent, but the parent key cannot be efficiently computed from the
// child.
//
// KeyTrees are opaque. They cannot be used for anything other than to derive
// more keys. Only leaf Keys can be used as keys in applications, via the
// `as_bytes` method. Each key commits to its role: leaf Keys and KeyTrees will
// not collide, even if they are derived from the same parent key with the same
// `id`.

use super::secret::Secret;
use rand_chacha::rand_core::{CryptoRng, RngCore};
use sha3::{Digest, Keccak256, Keccak512};
use std::convert::TryInto;
use zeroize::Zeroize;

// Salt used when deriving keys from passwords.
pub type Salt = [u8; 32];

#[derive(Clone, Debug)]
pub struct KeyTree(
    // Sub-trees are 64 bytes, twice as large as the actual keys, to make it much harder to break
    // security upwards through the tree. This is probably not strictly necessary (32 bytes is
    // already quite large) but it is an extra layer of security for sub-tree separation, which is
    // the most important security property of this system.
    //
    // BIP32 uses a similar idea by extending their keys with an extra 32 bytes of entropy (the
    // chain code).
    Secret<[u8; 64]>,
);

impl KeyTree {
    pub fn random(rng: &mut (impl CryptoRng + RngCore)) -> Self {
        let mut key = Secret::<[u8; 64]>::build();
        rng.fill_bytes(key.as_mut());
        Self(key.finalize())
    }

    pub fn from_password(
        rng: &mut (impl CryptoRng + RngCore),
        password: &[u8],
    ) -> Result<(Self, Salt), argon2::Error> {
        let mut salt = Salt::default();
        rng.fill_bytes(&mut salt);
        let key = Self::from_password_and_salt(password, &salt)?;
        Ok((key, salt))
    }

    pub fn from_password_and_salt(password: &[u8], salt: &[u8]) -> Result<Self, argon2::Error> {
        let mut key = Secret::<[u8; 64]>::build();
        let config = argon2::Config {
            hash_length: key.len() as u32,
            ..Default::default()
        };
        let mut hash = argon2::hash_raw(password, salt, &config)?;
        *key = hash.clone().try_into().unwrap();
        hash.zeroize();
        Ok(Self(key.finalize()))
    }

    pub fn derive_sub_tree(&self, id: &[u8]) -> KeyTree {
        // Note that the hash for deriving a new sub-tree does not need to include a commitment to
        // the role of the key (sub-tree vs key) because sub-trees and keys are different sizes and
        // thus cannot suffer from domain confusion.
        let mut digest = Keccak512::new()
            // Commit to the parent key.
            .chain(&*self.0)
            .chain(id)
            .finalize();
        // The try_into will always succeed, because the hash output size is a slice of 64 bytes.
        // There just isn't an `as_mut() -> &[u8; 64]` method for GenericArrays as large as 64.
        Self(Secret::new(digest.as_mut().try_into().unwrap()))
    }

    pub fn derive_key(&self, id: &[u8]) -> Key {
        // Note that the hash for deriving a new key does not need to include a commitment to the
        // role of the key (key vs sub-tree) because keys and sub-trees are different sizes and thus
        // cannot suffer from domain confusion.
        let mut digest = Keccak256::new()
            // Commit to the parent key.
            .chain(&*self.0)
            .chain(id)
            .finalize();
        Key(Secret::new(digest.as_mut()))
    }
}

#[derive(Clone, Debug)]
pub struct Key(Secret<[u8; 32]>);

impl Key {
    pub fn as_bytes(&self) -> &[u8; 32] {
        &*self.0
    }
}
