////////////////////////////////////////////////////////////////////////////////
// Hierarchical deterministic key generation
//
// This module provides an interface for procedurally generating a tree of keys.
// It does not implement the full BIP 32 standard for HD wallets, only the
// features relevant to our system. For example, BIP 32 provides features for
// deriving public keys from parent public keys without knowing any private keys,
// to allow for trustless key rotation. This (key rotation) is less important in
// our system, which provides unlinkability by default.
//
// The keys generated by this interface are 32-byte pseudo-random values with no
// internal structure. They have no relationship to elliptic curve points, but
// they can be used as a random seed for generating elliptic curve keys for use
// in the wallet. The lack of structure makes these keys useful for other
// applications too, though, such as encryption and decryption.
//
// The relationship between derived keys and their parents can be described as a
// tree. A single root KeyTree is generated from some external means (such as
// entropy, or from a password using a KDF). This root tree can be used to derive
// sub-trees using `derive_sub_tree`, and any KeyTree can be used to derive more
// sub-trees as well as leaf keys. Each derived KeyTree and Key is a commitment
// to its parent, but the parent key cannot be efficiently computed from the
// child.
//
// KeyTrees are opaque. They cannot be used for anything other than to derive
// more keys. Only leaf Keys can be used as keys in applications, via the
// `as_bytes` method. Each key commits to its role: leaf Keys and KeyTrees will
// not collide, even if they are derived from the same parent key with the same
// `id`.

use super::secret::Secret;
use rand_chacha::rand_core::{CryptoRng, RngCore};
use sha3::{Digest, Keccak256};
use std::convert::TryInto;
use zeroize::Zeroize;

// Salt used when deriving keys from passwords.
pub type Salt = [u8; 32];

#[derive(Clone, Debug)]
pub struct KeyTree(Secret<[u8; 32]>);

impl KeyTree {
    pub fn random(rng: &mut (impl CryptoRng + RngCore)) -> Self {
        let mut key = Secret::<[u8; 32]>::build();
        rng.fill_bytes(key.as_mut());
        Self(key.finalize())
    }

    pub fn from_password(
        rng: &mut (impl CryptoRng + RngCore),
        password: &[u8],
    ) -> Result<(Self, Salt), argon2::Error> {
        let mut salt = Salt::default();
        rng.fill_bytes(&mut salt);
        let key = Self::from_password_and_salt(password, &salt)?;
        Ok((key, salt))
    }

    pub fn from_password_and_salt(password: &[u8], salt: &[u8]) -> Result<Self, argon2::Error> {
        let mut key = Secret::<[u8; 32]>::build();
        let config = argon2::Config {
            hash_length: key.len() as u32,
            ..Default::default()
        };
        let mut hash = argon2::hash_raw(password, salt, &config)?;
        *key = hash.clone().try_into().unwrap();
        hash.zeroize();
        Ok(Self(key.finalize()))
    }

    pub fn derive_sub_tree(&self, id: &[u8]) -> KeyTree {
        let mut digest = Keccak256::new()
            // All derived sub-trees include the tag "sub_tree" in the digest, as a commitment to
            // their role as a tree of keys (not an individual Key) and as a domain separator from
            // derived Keys (which use a different tag).
            .chain("sub_tree".as_bytes())
            // Commit to the parent key.
            .chain(&*self.0)
            .chain(id)
            .finalize();
        Self(Secret::new(digest.as_mut()))
    }

    pub fn derive_key(&self, id: &[u8]) -> Key {
        let mut digest = Keccak256::new()
            // All derived keys include the tag "key" in the digest as a commitment to their role as
            // an individual Key (not a sub-tree of keys) and as a domain separator from derived
            // sub-trees (which use a different tag).
            .chain("key".as_bytes())
            // Commit to the parent key.
            .chain(&*self.0)
            .chain(id)
            .finalize();
        Key(Secret::new(digest.as_mut()))
    }
}

pub struct Key(Secret<[u8; 32]>);

impl Key {
    pub fn as_bytes(&self) -> &[u8; 32] {
        &*self.0
    }
}
